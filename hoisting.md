# Scope 

Scope (область видимости) в JavaScript определяет доступность переменных и функций в различных частях кода.

## Виды областей видимости

### Global Scope (глобальная область видимости)

Глобальная область видимости в JavaScript охватывает всю программу и доступна из любой части кода. Переменные и функции, объявленные в глобальной области видимости, доступны из любого места программы.

```javascript
var globalVariable = 10;

function globalFunction() {
    console.log("Это глобальная функция");
}
```

### Local Scope (локальная область видимости)

Локальная область видимости ограничивается внутри блока кода, например, функции или блока `{}`. Переменные и функции, объявленные внутри локальной области видимости, доступны только внутри этой области видимости.
```javascript
function localScopeExample() {
    var localVariable = 20;
    console.log(localVariable); // Выведет 20
}

localScopeExample();
console.log(localVariable); // Выдаст ReferenceError: localVariable не определена
```
### Block Scope (блочная область видимости)

Блочная область видимости была введена в ECMAScript 6 с появлением ключевых слов `let` и `const`. Переменные, объявленные с помощью `let` и `const`, имеют блочную область видимости, что означает, что они доступны только внутри блока кода, в котором они были объявлены, например, внутри цикла(`for` `while`) или условного оператора(`if` ``do while``).
```javascript
if (true) {
    let blockVariable = 30;
    console.log(blockVariable); // Выведет 30
}

console.log(blockVariable); // Выдаст ReferenceError: blockVariable не определена
```
# Hoisting

Hoisting - это механизм в JavaScript, который поднимает объявления переменных и функций в начало их области видимости во время компиляции, но не их присваивания. Это означает, что переменные и функции могут быть использованы до того, как они были объявлены в коде.

## Переменные и hoisting

Пример использования переменных:

```javascript
console.log(x); // Выведет undefined
var x = 5;
```

В этом примере переменная `x` объявлена после того, как она использована в `console.log`, но JavaScript не выдает ошибку. Это происходит из-за `hoistin`. При компиляции JavaScript перемещает объявление переменной x в начало текущей области видимости, но оставляет присваивание x = 5 на своем месте. Поэтому console.log(x) выводит undefined, потому что присваивание значения переменной x еще не произошло на момент вызова console.log.

### Функции и hoisting
Hoisting также применяется к объявлениям функций:
```Javascript
sayHello(); // Выведет "Привет!"
function sayHello() {
    console.log("Привет!");
}
```

Здесь функция `sayHello` вызывается до ее объявления в коде, но JavaScript все равно правильно выполнит вызов, потому что объявление функции поднимается в начало области видимости.

## 
Дополнительно, по поводу `let` и `const`: 

Переменные, объявленные с помощью `let` и `const`, также подвержены hoisting, но с некоторыми особенностями. В отличие от переменных, объявленных с помощью `var`, переменные `let` и `const` не инициализируются до момента фактического объявления, что означает, что вы не можете обращаться к ним до их объявления. Это называется "temporal dead zone" (временная мертвая зона). В этой зоне переменные существуют, но вы не можете к ним обращаться.

Пример:

```javascript
console.log(x); // Выдаст ReferenceError
let x = 5;
```
Этот код вызовет ошибку, потому что переменная `x` существует в момент вызова `console.log`, но находится в `"temporal dead zone"`, поэтому ее нельзя использовать до фактического объявления на следующей строке.

